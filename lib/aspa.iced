fs     = require 'fs'
clc    = require 'cli-color'
yaml   = require 'js-yaml'
path   = require 'path'
rimraf = require 'rimraf'
mkdirp = require 'mkdirp'
zlib   = require 'zlib'
uglify = require 'uglify-js'
csso   = require 'csso'
watchr = require 'watchr'

# Compilers producing .css output
stylus = require 'stylus'
nib    = require 'nib'
less   = require 'less'

# For .jade client-side templates
jade   = require 'jade'

# Map of compilers producing .js output
jsCompilers =
  '.coffee': require 'coffee-script'
  '.iced':   require 'iced-coffee-script'
  '.co':     require 'coco'
  '.ls':     require 'LiveScript'

# Regex for detecting & adjusting URLs of fingerprinted/compressed assets referred in .css files
stylesheetAssetUrlPattern = ///
  url\(             # url(
  [\'\"]?           # optional ' or "
  ([^\?\#\'\"\)]+)  # file                                       -> file
  ([^\'\"\)]*)      # optional suffix, i.e. #iefix in font URLs  -> suffix
  [\'\"]?           # optional ' or "
  \)                # )
///gi

# Don't need to call this every time, so cache it
cwd = process.cwd()


### ================================================================================================ Utility methods ###


# Build the asset output map to be written as aspa.json in the output root folder (in production mode)
buildOutputMap = (map, timestamp) ->
  outputMap = {}
  for own asset, options of map
    if timestamp
      # We're in production mode, so add timestamp fingerprint prefix and .gz suffix for compressed assets;
      # .js and .css files are always compressed in production
      output = path.basename asset
      output = "#{timestamp}.#{output}" unless options?.raw
      output += '.gz' if options?.compress or path.extname(asset) in ['.js', '.css']
      output = path.join path.dirname(asset), output
    else
      output = asset
    outputMap[asset] = output

  outputMap


# Build an object mapping the assets referred in .css files to their corresponding
# "production names", generated by buildOutputMap()
buildStylesheetAssetsMap = (map, outputMap) ->
  stylesheetAssetsMap = {}
  for own asset, options of map when path.extname(asset) not in ['.js', '.css']
    source = if options?.from then path.join options.from, path.basename(asset) else asset
    stylesheetAssetsMap[path.resolve('', source)] = outputMap[asset]

  stylesheetAssetsMap


# Copy a file, fingerprinting and compressing it as needed
copy = (asset, from, to, outputMap, callback) ->
  source = if from then path.join from, path.basename(asset) else asset
  destination = path.join to, outputMap[asset]

  # Delete old destination file if necessary
  await fs.exists destination, defer found
  await fs.unlink destination, defer err if found
  return callback err if err

  # Create destination path
  await mkdirp path.dirname(destination), defer err
  return callback err if err

  if path.extname(destination) is '.gz'
    # Compress asset
    await fs.readFile source, 'utf8', defer err, contents
    return callback err if err
    await zlib.gzip contents, defer err, contents
    return callback err if err
    await fs.writeFile destination, contents, defer err
    operation = 'compressed'
  else
    # Just copy asset
    await fs.link source, destination, defer err
    operation = 'copied'
  console.log clc.cyan "#{source} #{operation} to #{destination}." unless err
  callback err


# Build a 120 chars wide comment "separator" prefixing each individual source in the output .css and .js files
getSourceComment = (source) ->
  sourceLength = source.length
  comment = '/'
  comment += '*' for i in [0...118]
  comment += '/\n/'
  comment += '*' for i in [0...(115 - sourceLength)]
  comment += " #{source} */\n/"
  comment += '*' for i in [0...118]
  comment += '/\n\n'
  comment


# Detect & adjust URLs of fingerprinted/compressed assets referred in .css files
adjustStylesheetAssetUrls = (contents, sourceFolder, stylesheetAssetsMap) ->
  contents = contents.replace stylesheetAssetUrlPattern, (src, file, suffix) ->
    filePath = path.resolve sourceFolder, file
    if stylesheetAssetsMap[filePath]
      "url(\"/#{stylesheetAssetsMap[filePath]}#{suffix}\")"
    else
      src
  contents


# Compile an asset from multiple source files:
# .js files are built from .js, .coffee, .iced, .ls [...] components;
# .css files are built from .css, .styl, .less [...] components
compile = (asset, sources, to, outputMap, stylesheetAssetsMap, callback) ->
  assetExt = path.extname(asset)
  destination = path.join to, outputMap[asset]

  # Delete old destination file if necessary
  await fs.exists destination, defer found
  await fs.unlink destination, defer err if found
  return callback err if err

  # Create destination path
  await mkdirp path.dirname(destination), defer err
  return callback err if err

  contents = ''
  sourceCount = 0

  for own source, options of sources when options?.skip isnt on
    sourceCount += 1

    # Add a comment-separator before each source
    contents += '\n' unless contents is ''
    contents += getSourceComment(source)

    # Read source
    await fs.readFile source, 'utf8', defer err, content
    return callback err if err
    sourceExt = path.extname source

    # Perform compilation, depending on source extension
    switch sourceExt

      when '.styl'
        compiler = stylus(content)
          .set('filename', source)
          .set('compress', no)
          .set('debug', yes)
        compiler.use(nib()).import('nib') if options?.nib
        await compiler.render defer err, content
        return callback err if err

      when '.less'
        parser = new less.Parser
          filename: source
          paths: [ path.dirname(source) ]
        await parser.parse content, defer err, lessTree
        return callback err if err
        try
          content = lessTree.toCSS()
        catch err
          return callback err

      when '.coffee', '.iced', '.co', '.ls'
        # All JavaScript compilers are basically exposing the same API, so we can abstract a bit here
        compiler = jsCompilers[sourceExt]
        try
          content = compiler.compile content, { bare: options?.bare }
        catch err
          return callback err

      when '.jade'
        # Build template name from source file path & name, i.e. /templates/item.jade => JST['templates/item']
        templateName = path.join path.dirname(source), path.basename(source, '.jade')
        try
          content = jade.compile content, { client: yes, compileDebug: no }
          content = "JST['#{templateName}'] = #{content};\n"
        catch err
          return callback err

      else # no compilation needed, so nothing to do

    # Adjust URLs for assets reffered within CSS files
    content = adjustStylesheetAssetUrls content, path.dirname(source), stylesheetAssetsMap if assetExt is '.css'

    contents += content

  if path.extname(destination) is '.gz'
    # Perform optimizations depending on asset extension, then compress
    if assetExt is '.js'
      contents = uglify.minify(contents, { fromString: yes }).code
    else
      contents = csso.justDoIt contents
    await zlib.gzip contents, defer err, contents
    return callback err if err
    operation = 'compiled and compressed'
  else
    operation = 'compiled'

  # Write contents
  await fs.writeFile destination, contents, defer err
  console.log clc.cyan "#{sourceCount} source file(s) #{operation} to #{destination}." unless err
  callback err


### =============================================================================================== Exported methods ###


# Cleanup public folder and delete existent output map
exports.cleanup = cleanup = (options, callback) ->
  outputMapFile = "#{options.root}#{path.sep}aspa.json"

  # Delete old output map if necessary
  await fs.exists outputMapFile, defer found
  await fs.unlink outputMapFile, defer err if found
  return callback err if err

  # Recreate public folder
  await rimraf options.public, defer err
  return callback err if err
  await fs.mkdir options.public, defer err

  console.log clc.green 'Cleanup finished.' unless err
  callback err


# Build assets in current folder for development or production
exports.build = build = (options, callback) ->

  # Perform a cleanup first
  await cleanup options, defer err
  return callback err if err

  timestamp = (new Date).getTime().toString() if options.mode is 'production'

  map = require path.join(cwd, 'aspa.yml')
  outputMap = buildOutputMap map, timestamp
  stylesheetAssetsMap = buildStylesheetAssetsMap map, outputMap

  # Process asset map
  for own asset, assetOptions of map
    await
      if path.extname(asset) in ['.js', '.css']
        compile asset, assetOptions.from, options.public, outputMap, stylesheetAssetsMap, defer err
      else
        copy asset, assetOptions?.from, options.public, outputMap, defer err
    return callback err if err

  # Write output map if mode is production
  if options.mode is 'production'
    await fs.writeFile path.join(options.root, 'aspa.json'), JSON.stringify(outputMap, null, '\t'), defer err

  console.log clc.green 'Build finished.' unless err
  callback err


# Continuously watch the current folder, building assets as source files change
exports.watch = (options, callback) ->
  unless options.mode is 'development'
    callback 'Watch only works for development mode.'
    return

  watcher = null

  # Wrapper method so we can restart on map file change
  work = ->
    # Perform a build first
    await build options, defer err
    callback err if err

    mapFile = path.join(cwd, 'aspa.yml')
    await fs.readFile mapFile, 'utf8', defer err, mapFileContents
    callback err if err
    map = yaml.load mapFileContents

    outputMap = buildOutputMap map
    stylesheetAssetsMap = buildStylesheetAssetsMap map, outputMap

    console.log clc.yellow 'Watching folder (press Ctrl+C to exit)...'

    # Close any existent file watches (in case of restart)
    watcher?.close()

    watcher = watchr.watch
      preferredMethods: ['watchFile', 'watch']     # Needed for Node.js > 0.8.x, not sure yet why...
      interval: 500                                # Don't trigger too often
      path: cwd
      listener: (e, file) ->

        # Restart work when input asset map file is changed
        if file is mapFile and e is 'update'
          console.log clc.yellow 'Source map file changed, restarting...'
          work()
          return

        # Copy or compile corresponding targets when a source file changes
        if e in ['create', 'update']
          for own asset, assetOptions of map
            if path.extname(asset) in ['.js', '.css']
              for own source of assetOptions.from
                if file is path.resolve(cwd, source)
                  await compile asset, assetOptions.from, options.public, outputMap, stylesheetAssetsMap, defer err
                  callback err if err
            else
              source = if assetOptions?.from then path.join assetOptions.from, path.basename(asset) else asset
              if file is path.resolve(cwd, source)
                await copy asset, assetOptions?.from, options.public, outputMap, defer err
                callback err if err

  work()
